#!/usr/bin/env bash

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Function to show usage
show_usage() {
    echo -e "${BLUE}Usage:${NC}"
    echo "  $0 [options] <url>"
    echo ""
    echo -e "${YELLOW}Options:${NC}"
    echo "  -i, --interval <seconds>    Check interval in seconds (default: 10)"
    echo "  -t, --timeout <seconds>     Maximum runtime in seconds (default: 43200 = 12 hours, 0 = unlimited)"
    echo "  -s, --stop-on-change        Stop monitoring on first change detected (default: continue monitoring)"
    echo "  -h, --help                  Show this help message"
    echo ""
    echo -e "${YELLOW}Examples:${NC}"
    echo "  $0 https://api.example.com/status"
    echo "  $0 --interval 10 https://api.example.com/health"
    echo "  $0 -i 2 -t 3600 https://api.example.com/status"
    echo "  $0 --stop-on-change https://api.example.com/status"
    echo "  $0 -i 5 -t 0 -s https://api.example.com/status    # unlimited runtime, stop on change"
    echo ""
}

# Default values
INTERVAL=10
MAX_RUNTIME=43200  # Default: 12 hours
STOP_ON_CHANGE=false
ENDPOINT=""

# Parse arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            show_usage
            exit 0
            ;;
        -i|--interval)
            if [[ -n "$2" && "$2" =~ ^[0-9]+$ ]]; then
                INTERVAL="$2"
                shift 2
            else
                echo -e "${RED}Error: --interval requires a numeric value${NC}"
                exit 1
            fi
            ;;
        -t|--timeout)
            if [[ -n "$2" && "$2" =~ ^[0-9]+$ ]]; then
                MAX_RUNTIME="$2"
                shift 2
            else
                echo -e "${RED}Error: --timeout requires a numeric value${NC}"
                exit 1
            fi
            ;;
        -s|--stop-on-change)
            STOP_ON_CHANGE=true
            shift
            ;;
        -*)
            echo -e "${RED}Error: Unknown option $1${NC}"
            show_usage
            exit 1
            ;;
        *)
            if [[ -z "$ENDPOINT" ]]; then
                ENDPOINT="$1"
                shift
            else
                echo -e "${RED}Error: Multiple URLs provided. Only one URL is allowed.${NC}"
                show_usage
                exit 1
            fi
            ;;
    esac
done

# Check if URL was provided
if [[ -z "$ENDPOINT" ]]; then
    echo -e "${RED}Error: URL is required${NC}"
    echo ""
    show_usage
    exit 1
fi

# Validate URL argument
if [[ ! "$ENDPOINT" =~ ^https?:// ]]; then
    echo -e "${RED}Error: URL must start with http:// or https://${NC}"
    echo ""
    show_usage
    exit 1
fi

TEMP_DIR="/tmp/url-monitor-$$"

echo -e "${BLUE}Monitoring URL: ${ENDPOINT}${NC}"
echo -e "${BLUE}Check interval: ${INTERVAL} seconds${NC}"
if [[ "$MAX_RUNTIME" == "0" ]]; then
    echo -e "${BLUE}Maximum runtime: unlimited${NC}"
else
    echo -e "${BLUE}Maximum runtime: ${MAX_RUNTIME} seconds ($((MAX_RUNTIME/3600))h $((MAX_RUNTIME%3600/60))m)${NC}"
fi
if [[ "$STOP_ON_CHANGE" == "true" ]]; then
    echo -e "${BLUE}Stop on change: yes${NC}"
else
    echo -e "${BLUE}Stop on change: no${NC}"
fi
echo -e "${YELLOW}Press Ctrl+C to stop monitoring${NC}"
echo ""

# Create temp directory for storing responses
mkdir -p "$TEMP_DIR"
CURRENT_FILE="$TEMP_DIR/current.json"
PREVIOUS_FILE="$TEMP_DIR/previous.json"

# Function to cleanup on exit
cleanup() {
    echo -e "\n${YELLOW}Cleaning up...${NC}"
    if [[ ${CHANGE_COUNT:-0} -gt 0 ]]; then
        echo -e "${BLUE}Total changes detected: ${CHANGE_COUNT}${NC}"
    fi
    rm -rf "$TEMP_DIR"
    exit 0
}

# Trap cleanup on script exit
trap cleanup EXIT INT TERM

# Function to format JSON nicely
format_json() {
    if command -v jq &> /dev/null; then
        jq '.' "$1" 2>/dev/null || cat "$1"
    else
        cat "$1"
    fi
}

# Function to show diff
show_diff() {
    CHANGE_COUNT=$((CHANGE_COUNT + 1))
    echo -e "\n${RED}CHANGE DETECTED #${CHANGE_COUNT} at $(date)!${NC}"
    echo ""
    
    if command -v diff &> /dev/null && command -v jq &> /dev/null; then
        echo -e "${YELLOW}Formatted diff:${NC}"
        echo "--- Previous response"
        echo "+++ Current response"
        diff -u <(jq -S '.' "$PREVIOUS_FILE" 2>/dev/null || cat "$PREVIOUS_FILE") \
                <(jq -S '.' "$CURRENT_FILE" 2>/dev/null || cat "$CURRENT_FILE") || true
    else
        echo -e "${YELLOW}Previous response:${NC}"
        format_json "$PREVIOUS_FILE"
        echo ""
        echo -e "${YELLOW}Current response:${NC}"
        format_json "$CURRENT_FILE"
    fi
    
    echo ""
    
    if [[ "$STOP_ON_CHANGE" == "true" ]]; then
        echo -e "${GREEN}Monitoring stopped due to detected change.${NC}"
        exit 0
    else
        echo -e "${BLUE}Continuing to monitor for additional changes...${NC}"
        echo ""
    fi
}

# Initial fetch
echo -e "${BLUE}Fetching initial state...${NC}"
if curl -s --fail --max-time 10 "$ENDPOINT" > "$CURRENT_FILE" 2>/dev/null; then
    echo -e "${GREEN}Initial state captured:${NC}"
    format_json "$CURRENT_FILE"
    echo ""
    cp "$CURRENT_FILE" "$PREVIOUS_FILE"
else
    echo -e "${RED}Failed to fetch from endpoint: $ENDPOINT${NC}"
    echo "Please check:"
    echo "1. The endpoint URL is correct"
    echo "2. The service is running"
    echo "3. You have network connectivity"
    exit 1
fi

# Initialize change counter
CHANGE_COUNT=0

# Start monitoring loop
echo -e "${BLUE}Starting monitoring...${NC}"
echo ""

# Record start time for timeout checking
START_TIME=$(date +%s)

while true; do
    sleep "$INTERVAL"
    
    # Check timeout if not unlimited (0)
    if [[ "$MAX_RUNTIME" != "0" ]]; then
        CURRENT_TIME=$(date +%s)
        ELAPSED=$((CURRENT_TIME - START_TIME))
        
        if [[ $ELAPSED -ge $MAX_RUNTIME ]]; then
            echo -e "\n${YELLOW}Maximum runtime reached (${MAX_RUNTIME} seconds / $((MAX_RUNTIME/3600))h $((MAX_RUNTIME%3600/60))m)${NC}"
            if [[ $CHANGE_COUNT -eq 0 ]]; then
                echo -e "${BLUE}No changes detected during monitoring period.${NC}"
            else
                echo -e "${BLUE}Total changes detected: ${CHANGE_COUNT}${NC}"
            fi
            exit 2
        fi
    fi
    
    # Fetch current state
    if curl -s --fail --max-time 10 "$ENDPOINT" > "$CURRENT_FILE" 2>/dev/null; then
        # Compare with previous state
        if ! cmp -s "$CURRENT_FILE" "$PREVIOUS_FILE"; then
            show_diff
        else
            echo -n "."
        fi
        
        # Update previous state
        cp "$CURRENT_FILE" "$PREVIOUS_FILE"
    else
        echo -e "\n${RED}Failed to fetch endpoint ($(date))${NC}"
        echo -n "!"
    fi
done
