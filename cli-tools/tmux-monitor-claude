#!/usr/bin/env bash
#
# tmux-monitor-claude - Monitor all Claude Code instances in a single window
# Creates a grid of panes that continuously display Claude sessions with color

set -e

# Get current session and window
CURRENT_SESSION=$(tmux display-message -p '#S')
CURRENT_WINDOW=$(tmux display-message -p '#I')

# Debug mode
DEBUG=${DEBUG:-false}

# Update interval (in seconds) for individual pane refreshes
UPDATE_INTERVAL=${UPDATE_INTERVAL:-1}

# Check interval (in seconds) for detecting new/stopped Claude processes
CHECK_INTERVAL=${CHECK_INTERVAL:-5}

# Cleanup function for graceful shutdown
cleanup() {
    if [ "$DEBUG" = true ]; then
        echo "Shutting down monitor..." >&2
    fi
    exit 0
}

trap cleanup SIGINT SIGTERM

# Function to find all Claude processes and their tmux panes
find_claude_panes() {
    # Find all claude processes and trace back to tmux panes
    pgrep "claude" 2>/dev/null | while read claude_pid; do
        if [ "$DEBUG" = true ]; then
            echo "Found claude PID: $claude_pid" >&2
        fi

        # Walk up the process tree to find tmux pane
        local current_pid=$claude_pid
        local max_depth=10

        while [ $max_depth -gt 0 ]; do
            # Get parent PID
            local parent_pid=$(ps -p "$current_pid" -o ppid= 2>/dev/null | tr -d ' ' || true)

            if [ -z "$parent_pid" ] || [ "$parent_pid" = "1" ]; then
                break
            fi

            # Check if parent is a tmux pane
            local pane_info=$(tmux list-panes -a -F '#S:#I.#P:#{pane_pid}' 2>/dev/null | grep ":${parent_pid}$" || true)

            if [ -n "$pane_info" ]; then
                # Extract the pane spec (everything before the last colon)
                local spec=$(echo "$pane_info" | sed 's/:[^:]*$//')
                local session=$(echo "$spec" | cut -d: -f1)
                local window_pane=$(echo "$spec" | cut -d: -f2)
                local window=$(echo "$window_pane" | cut -d. -f1)

                # Skip current window to avoid recursion
                if [ "$session" = "$CURRENT_SESSION" ] && [ "$window" = "$CURRENT_WINDOW" ]; then
                    if [ "$DEBUG" = true ]; then
                        echo "  Skipping current window" >&2
                    fi
                    break
                fi

                if [ "$DEBUG" = true ]; then
                    echo "  Found in pane: $spec" >&2
                fi
                echo "$spec"
                break
            fi

            current_pid=$parent_pid
            ((max_depth--))
        done
    done | sort -u
}

# Function to create a monitoring pane for a specific Claude session
create_monitor_pane() {
    local pane_spec=$1
    local session_name=$(echo "$pane_spec" | cut -d: -f1)
    local pane_count=$2

    # Change detection approach - only update when content actually changes
    local monitor_cmd='content=$(tmux capture-pane -t "'$pane_spec'" -e -p); printf "\\033[2J\\033[H"; echo "$content"; prev_hash=$(echo "$content" | cksum | cut -d" " -f1); while true; do content=$(tmux capture-pane -t "'$pane_spec'" -e -p); current_hash=$(echo "$content" | cksum | cut -d" " -f1); if [ "$current_hash" != "$prev_hash" ]; then printf "\\033[2J\\033[H"; echo "$content"; prev_hash="$current_hash"; fi; sleep '$UPDATE_INTERVAL'; done'

    # Alternate between horizontal and vertical splits for better grid layout
    local split_flag=""
    if [ $((pane_count % 2)) -eq 0 ]; then
        split_flag="-h"
    fi

    # Always create a new pane (never use pane 0 since that's where the main loop runs)
    tmux split-window $split_flag -t "$CURRENT_SESSION:$CURRENT_WINDOW" "$monitor_cmd"
    local new_pane=$(tmux display-message -p '#{pane_index}')
    tmux set-option -p -t "$CURRENT_SESSION:$CURRENT_WINDOW.$new_pane" @claude_target "$pane_spec"

    # Set pane title
    tmux select-pane -t "$CURRENT_SESSION:$CURRENT_WINDOW.$new_pane" -T "$session_name"
}

# Function to get currently monitored Claude panes
get_monitored_panes() {
    tmux list-panes -t "$CURRENT_SESSION:$CURRENT_WINDOW" -F '#{@claude_target}' 2>/dev/null | grep -v '^$' | sort -u || true
}

# Function to update the monitoring window layout
update_monitor_layout() {
    local -a new_panes=("$@")

    if [ "$DEBUG" = true ]; then
        echo "Updating layout with ${#new_panes[@]} Claude sessions" >&2
    fi

    # Get currently monitored panes
    local -a current_panes=()
    while IFS= read -r pane_spec; do
        if [ -n "$pane_spec" ]; then
            current_panes+=("$pane_spec")
        fi
    done < <(get_monitored_panes)

    # Find panes to remove (monitored but no longer in new list)
    for monitored in "${current_panes[@]}"; do
        local found=false
        for new_pane in "${new_panes[@]}"; do
            if [ "$monitored" = "$new_pane" ]; then
                found=true
                break
            fi
        done

        if [ "$found" = false ]; then
            if [ "$DEBUG" = true ]; then
                echo "Removing pane monitoring: $monitored" >&2
            fi
            # Find and kill the pane monitoring this target
            local pane_to_kill=$(tmux list-panes -t "$CURRENT_SESSION:$CURRENT_WINDOW" -F '#{pane_index}:#{@claude_target}' | grep ":${monitored}$" | cut -d: -f1)
            if [ -n "$pane_to_kill" ]; then
                tmux kill-pane -t "$CURRENT_SESSION:$CURRENT_WINDOW.$pane_to_kill" 2>/dev/null || true
            fi
        fi
    done

    # Find panes to add (in new list but not currently monitored)
    local pane_index=0
    for new_pane in "${new_panes[@]}"; do
        local found=false
        for monitored in "${current_panes[@]}"; do
            if [ "$new_pane" = "$monitored" ]; then
                found=true
                break
            fi
        done

        if [ "$found" = false ]; then
            if [ "$DEBUG" = true ]; then
                echo "Adding pane monitoring: $new_pane" >&2
            fi
            create_monitor_pane "$new_pane" "$pane_index"
            ((pane_index++))
        fi
    done

    # Arrange in tiled layout if we have multiple panes
    local final_count=$(tmux list-panes -t "$CURRENT_SESSION:$CURRENT_WINDOW" | wc -l)
    if [ "$final_count" -gt 1 ]; then
        tmux select-layout -t "$CURRENT_SESSION:$CURRENT_WINDOW" tiled
        # Select back to pane 0 (the control pane)
        tmux select-pane -t "$CURRENT_SESSION:$CURRENT_WINDOW.0"
    fi
}

# Main function
main() {
    # Check if we're in a tmux session
    if [ -z "$TMUX" ]; then
        echo "Error: This script must be run from within a tmux session"
        exit 1
    fi

    echo "Searching for Claude sessions..."

    # Initial setup
    local -a previous_panes=()
    local initial_run=true

    # Enable pane borders with titles and make them bright
    tmux set-window-option -t "$CURRENT_SESSION:$CURRENT_WINDOW" pane-border-status top
    tmux set-window-option -t "$CURRENT_SESSION:$CURRENT_WINDOW" pane-border-format "#{?pane_active,#[reverse],}#[fg=brightmagenta,bold]#{pane_title}#[default]"

    # Bind Ctrl+b Enter to jump to Claude session
    tmux bind-key -T prefix Enter run-shell 'tmux-claude-jump'

    # Rename the window
    tmux rename-window -t "$CURRENT_SESSION:$CURRENT_WINDOW" "claude-monitor"

    # Continuous monitoring loop
    while true; do
        # Find all Claude panes
        claude_panes=()
        while IFS= read -r pane_spec; do
            if [ -n "$pane_spec" ]; then
                claude_panes+=("$pane_spec")
                if [ "$DEBUG" = true ]; then
                    echo "Found pane: $pane_spec" >&2
                fi
            fi
        done < <(find_claude_panes)

        # Check if the list has changed
        local has_changed=false

        if [ ${#claude_panes[@]} -ne ${#previous_panes[@]} ]; then
            has_changed=true
        else
            # Same length, check if all elements are the same
            for i in "${!claude_panes[@]}"; do
                if [ "${claude_panes[$i]}" != "${previous_panes[$i]}" ]; then
                    has_changed=true
                    break
                fi
            done
        fi

        # Update layout if changed or initial run
        if [ "$has_changed" = true ] || [ "$initial_run" = true ]; then
            if [ "$initial_run" = true ]; then
                if [ ${#claude_panes[@]} -eq 0 ]; then
                    echo "No Claude sessions found."
                    echo "Active claude processes:"
                    ps aux | grep "claude " | grep -v grep | grep -v "tmux-monitor" | head -5
                    echo ""
                    echo "Waiting for Claude sessions to start..."
                else
                    echo "Found ${#claude_panes[@]} Claude session(s)"
                    echo "Setting up monitor view..."
                    echo "  • Pane updates: every ${UPDATE_INTERVAL}s"
                    echo "  • Process checks: every ${CHECK_INTERVAL}s"
                    echo
                    echo "Controls:"
                    echo "  • Ctrl+b Enter: Jump to the Claude session being monitored"
                    echo "  • Ctrl+b arrows: Navigate between panes"
                    echo "  • Ctrl+b z: Zoom in/out of current pane"
                    echo "  • Ctrl+c: Stop monitoring daemon"
                    echo
                fi
                initial_run=false
            else
                # Show update message
                echo "[$(date +%H:%M:%S)] Detected change: ${#previous_panes[@]} → ${#claude_panes[@]} Claude sessions"
            fi

            # Update the layout if we have Claude panes
            if [ ${#claude_panes[@]} -gt 0 ]; then
                update_monitor_layout "${claude_panes[@]}"
            fi

            # Update previous panes
            previous_panes=("${claude_panes[@]}")
        fi

        # Sleep before next check
        sleep "$CHECK_INTERVAL"
    done
}

main "$@"